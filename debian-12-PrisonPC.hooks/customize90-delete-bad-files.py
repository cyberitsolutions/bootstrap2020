#!/usr/bin/python3
import argparse
import ctypes
import ctypes.util
import logging
import os
import pathlib
import shutil
import subprocess
import sys

__doc__ = r""" if we can't remove it, block it

We can't avoid shipping some binaries like gnupg(1), because
they're genuinely needed at boot time.

If they're ONLY needed at build time, delete them.
If they're needed at boot time, but ONLY by root, chmod them.

Why we don't |tar --delete
============================================================
The most logical way to do removals is outside of mmdebstrap:

    mmdebstrap … fs.sq          # BEFORE

    mmdebstrap … - |            # AFTER
    tar --delete --wildcards … |
    tar2sqfs fs.sq

But this runs into a few problems:

  • python3.9 pipeline process is a little fiddly if you want to make
    sure all processes exited nonzero.

  • systemd puts ACLs on /var/log/journal that tar2sqfs can't handle.
    Normally mmdebstrap auto-strips them, but when we tar2sqfs ourselves, I can't see how.
    Simply adding --xattrs-exclude=system.* to OUR tar didn't work.
    This didn't actually error, though, so we could just ignore this.

        $ <x.tar tar --xattrs --xattrs-exclude=system.*  --delete ./dev | tar2sqfs --quiet x.sq
        WARNING: squashfs does not support xattr prefix of system.posix_acl_default
        WARNING: squashfs does not support xattr prefix of system.posix_acl_access
        $ echo $?
        0

  • tar --delete --wildcards has no equivalent of shopt -s nullglob.
    We want to say "remove /bin/gpg (if not there, ignore)" not
    "remove /bin/gpg (if not there, half and catch fire)".

  • tar --delete -vvv still doesn't print "removing foo" or similar.
    Past experience has shown that when you have a large number of
    delete rules, you REALLY want an easy logged way to say "oh, shit,
    /bin/gpgame-rpg was wrongly deleted because it looked like GPG,
    but it's actually a game".


Why we don't bash extglob
============================================================
In the old codebase, we just did basically

    # chroot $1 bash -v < delete-bad-files.bash
    shopt -s globstar extglob nullglob
    shopt -u failglob
    rm -vrf *badthing*
    removing '/usr/bin/badthing'
    removing '/var/cache/badthing/'
    removing '/usr/lib/libbadthing.so.0'

This no longer works because mmdebstrap mounts /proc and /sys, and
bash and python globs lack "--one-file-system" or "-xdev".


Why we don't --dpkgopt=path-exclude=**bin/foo
============================================================
No one single reason, but:

  * cannot path-exclude files generated by postinst

  * cannot path-exclude files needed at build time (but not post-build).
    For example, initramfs config.

  * harder to debug, because dpkg does not log

     "skipped $path due to path-exclude $pattern"


UPDATE 2023 - Path.match ≠ Path.glob ≠ fnmatch.fnmatch ≠ fnmatch(3)
=====================================================================
OK so originally this used bash extglobs, where

    **  matches zero or more bytes (including /)
    *   matches zero or more bytes (excluding /)
    @(x|y|z)
    ?(x|y|z)
    !(x|y|z)   all work

Then I changed to Path.glob which lost support for the (x|y|z) extglobs, but
still implemented both ** and *.

But that broke because mmdebstrap still has /proc and /sys and /dev mounted, and
I want --one-file-system semantics.

So I changed that to use find -xdev, and then fnmatch.fnmatch.
But fnmatch.fnmatch treats every * as a bash **.

And I really like Path objects, so I changed to Path.match.
But Path.match treats every * as bash *, i.e.
if I want to match

     /usr/lib/libreoffice/share/config/soffice.cfg/svt/ui/placeedit.ui
     /lib/libreoffice/share/config/soffice.cfg/svt/ui/placeedit.ui

I cannot write

     **/lib/libreoffice/**/placeedit.ui

I have to write both of these:

     */lib/libreoffice/*/*/*/*/*/placeedit.ui
     /lib/libreoffice/*/*/*/*/*/placeedit.ui

So I was bitching about this when grawity pointed out that in glibc fnmatch(3),
you still don't have BOTH * (any excluding /) and ** (any including /), BUT
it is configurable (FNM_PATHNAME) and you get extglob semantics back.

That is very useful for occasional case of deleting everything EXCEPT a badlist

    plugins/!(allowA|allowB).so

It also allows you to concisely write

    *bin/(badA|badB|⋯|badZ)

instead of

    *bin/badA
    *bin/badB
    ⋮
    *bin/badZ

But then if upstream renames "badB" to "badderB",
you will not get a warning because the pattern still matches "badA".
So I ended up NOT going back to the *bin/@(⋯) style we had back in the original bash version.

I also noticed that using glibc fnmatch for this is 60% to 300% faster!
Apparently the cost of marshalling the Python strings into C is much cheaper
than letting python implement fnmatch in terms of python regexps?

(Note that this is also one reason we're happy to let find(1) walk the tree –
as well as supporting -xdev, it is MUCH faster than python iterdir() or os.walk.)

PS: one gotcha that still exists:

    /usr/src     path
    /usr/src     this pattern WILL match
    usr/src      this pattern WON'T match
    usr/src/     this pattern WON'T match

This whole thing is really just irritating and confusing.
The only reason I haven't thrown the whole thing away and
gone to re.fullmatch is because . is special in regexps, and
it's annoying to write things like ".*bin/libfoo-.*\.py" over and over.

Maybe if more languages had SREs by now I'd be writing it like this:

    ELISP> (rx string-start (or "/bin/" "/usr/bin/" "/sbin/" "/usr/sbin/") "libfoo-" (one-or-more any) ".py" string-end)
    "\\`\\(?:/\\(?:\\(?:s\\|usr/s?\\)?bin/\\)\\)libfoo-.+\\.py\\'"

At which point I could even have shorthand in the file, like

    ELISP> (setq binary-prefix (rx "/" (or "bin" "usr/bin" "sbin" "usr/sbin") "/"))   ; once, in the setup script
    "/\\(?:\\(?:s\\|usr/s?\\)?bin\\)/"

    ELISP> (rx (regexp binary-prefix) "libfoo-" (one-or-more any) ".py")              ; each rule -- clearer and consistenter
    "\\(?:/\\(?:\\(?:s\\|usr/s?\\)?bin\\)/\\)libfoo-.+\\.py"


"""


# NOTE: if we do not use b'' and do not declare argtypes, we can feed u'' into fnmatch, BUT
#       it assumes fnmatch(3) accepts wchar* -- which it DOES NOT.
_fnmatch = ctypes.CDLL(ctypes.util.find_library('c')).fnmatch
_fnmatch.argtypes = ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int


def glibc_fnmatch(path: pathlib.Path, pattern: str) -> bool:
    # FNM_PATHNAME = 1 << 0
    FNM_EXTMATCH = 1 << 5
    return 0 == _fnmatch(
        # FIXME: bytes(Path(b'')) works
        #        bytes(Path(u'')) works
        #        bytes(b'') works
        #        bytes(u'') fails
        #        bytes(u'', encoding='UTF-8') works
        #        bytes(b'', encoding='UTF-8') fails
        #        So this bullshit is making assumptions about the input datatypes.
        bytes(pattern, encoding='UTF-8'),
        bytes(path),
        # FNM_PATHNAME |
        FNM_EXTMATCH)


parser = argparse.ArgumentParser(description=__doc__)
parser.add_argument('chroot_path', type=pathlib.Path)
parser.set_defaults(shitlist_path=(
    pathlib.Path(sys.argv[0]).parent /  # noqa: W504
    'customize90-delete-bad-files.glob'))
args = parser.parse_args()

# Save the list of "deleted file X" into the squashfs by default.
os.umask(0o0077)                # not readable by inmates
logging.basicConfig(
    filename=(
        args.chroot_path /
        'var/log/bootstrap2020-delete-bad-files.log'),
    level=logging.INFO)

if args.chroot_path.resolve() == '/':
    raise RuntimeError('Refusing to trash your rootfs!')

# Walk the filesystem exactly once, with -xdev.
# Then, use python globbing to decide what to remove.
shitlist = frozenset({
    line
    for line in args.shitlist_path.read_text().splitlines()
    if line
    if not line.startswith('#')})
stdout = subprocess.check_output(
    ['chroot', args.chroot_path,
     'find', '-O3', '/', '-xdev', '-depth',
     '-print0'],
    text=True)
paths = [
    pathlib.Path(path)
    for path in stdout.strip('\0').split('\0')
    if path]          # ∵ ''.split() == [], but ''.split('x') == ['']!
ever_matching_globs: set[pathlib.Path]
ever_matching_globs = set()
for path in paths:
    if matching_globs := frozenset({
            glob
            for glob in shitlist
            if glibc_fnmatch(path, glob)}):
        ever_matching_globs |= matching_globs
        # NOTE: "chroot_path / path" does the Wrong ThingTM as path is absolute.
        path_outside_chroot = args.chroot_path.joinpath(*path.parts[1:])
        if path_outside_chroot.is_dir():
            shutil.rmtree(path_outside_chroot)
            was_dir = True
        else:
            path_outside_chroot.unlink()
            was_dir = False
        logging.info('Removed %s\t‘%s’\t(matches %s)',
                     'dir' if was_dir else 'file',
                     path,
                     sorted(matching_globs))

# It is entirely expected that some patterns will not match
# (e.g. "remove dbclient" only triggers when dropbear is installed).
# So this is not a halt-and-catch-fire error, but
# it might be worth logging for the occasional sanity-check.
for glob in sorted(shitlist - ever_matching_globs):
    logging.warning('Pattern ‘%s’ matched no files.', glob)
